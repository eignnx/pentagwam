HumanPoweredVm(
    fields: {
        "X1": FieldData(
            ty: CellRef,
            default: None,
            aliases: [
                "A1",
            ],
        ),
        "X2": FieldData(
            ty: CellRef,
            default: None,
            aliases: [
                "A2",
            ],
        ),
        "X3": FieldData(
            ty: CellRef,
            default: None,
            aliases: [
                "A3",
            ],
        ),
        "X4": FieldData(
            ty: CellRef,
            default: None,
            aliases: [
                "A4",
            ],
        ),
        "heap_ptr": FieldData(
            ty: CellRef,
            default: None,
            aliases: [
                "H",
                "hp",
            ],
        ),
        "instr_ptr": FieldData(
            ty: Usize,
            default: Some(Usize(0)),
            aliases: [
                "P",
                "ip",
            ],
        ),
        "mode": FieldData(
            ty: Symbol,
            default: Some(Symbol("read")),
            aliases: [],
        ),
        "structure_ptr": FieldData(
            ty: CellRef,
            default: None,
            aliases: [
                "S",
            ],
        ),
    },
    instr_scripts: {
        "get_structure": Script(
            lines: [
                Doc("# The `get_structure` instruction starts by dereferencing A1"),
                Doc("# and checking whether it is free"),
                Doc("# - If it is free, it sets the current mode to `Mode::Write`. This makes"),
                Doc("# the rest of the `get_structure` behave like `put_structure`, and it"),
                Doc("# makes the subsequent `unify_variable` instructions behave like"),
                Doc("# `set_variable`."),
                Doc("# - If it is bound, it sets the current mode to `Mode::Read`. This makes"),
                Doc("# the rest of the `get_structure` and the subsequent `unify_variable`"),
                Doc("# instructions do matching against the existing term, instead of"),
                Doc("# constructing a new one."),
                Doc("# "),
                Doc("# # Alternate Explanation"),
                Doc("# This instruction marks the beginning of a structure (without embedded"),
                Doc("# substructures) occurring as a head argument. The instruction gets the"),
                Doc("# value of register Ai and dereferences it. If the result is a"),
                Doc("# reference to a variable, that variable is bound to a new structure"),
                Doc("# pointer pointing at the top of the heap, and the binding is trailed"),
                Doc("# if necessary, functor F is pushed onto the heap, and execution"),
                Doc("# proceeds in \"write\" mode. Otherwise, if the result is a structure and"),
                Doc("# its functor is identical to functor F, the pointer S is set to point"),
                Doc("# to the arguments of the structure, and execution proceeds in \"read\""),
                Doc("# mode. Otherwise, backtracking occurs."),
                Doc(""),
                Doc("# Script for instruction `get_structure`"),
                Doc("# Feel free to edit this file however you like."),
                Doc("# Remember to use `$1`, `$2`, etc to refer to the instruction\'s parameters."),
                Doc(""),
                Cmd("  $1.*"),
                Cmd("  .reply <- ask bound or unbound?"),
                Cmd("  if .reply == :bound"),
                Cmd("      mode <- :read"),
                Cmd("      .heap_f <- $1.*[0]"),
                Cmd("      if .heap_f == $2"),
                Cmd("          S <- $1.*[1].&"),
                Cmd("      end"),
                Cmd("  else"),
                Cmd("      :todo"),
                Cmd("  end"),
                Cmd("  next"),
            ],
        ),
        "unify_variable": Script(
            lines: [
                Doc("# # unify_variable Vn"),
                Doc("# This instruction represents a head structure argument that is an"),
                Doc("# unbound variable. If the instruction is executed in \"read\" mode, it"),
                Doc("# simply gets the next argument from S and stores it in variable Vn. If"),
                Doc("# the instruction is executed in \"write\" mode, it pushes a new unbound"),
                Doc("# variable onto the heap, and stores a reference to it in variable Vn."),
                Doc("# "),
                Doc("# In read mode:"),
                Doc("# "),
                Doc("# Vn := next_term(S)"),
                Doc("# "),
                Doc("# In write mode:"),
                Doc("# "),
                Doc("# Vn := next_term(H) = tag_ref(H)"),
                Doc(""),
                Doc("# Script for instruction `unify_variable`"),
                Doc("# Feel free to edit this file however you like."),
                Doc("# Remember to use `$1`, `$2`, etc to refer to the instruction\'s parameters."),
                Doc(""),
                Cmd(" if mode == :read"),
                Cmd("     $1.* <- S.*"),
                Cmd("     S <- S[1].&"),
                Cmd(" else"),
                Cmd("     push tm _"),
                Cmd("     $1 <- H"),
                Cmd(" end"),
                Doc(""),
            ],
        ),
    },
    preferred_editor: Some("notepad.exe"),
)