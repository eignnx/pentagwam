HumanPoweredVm(
    fields: {
        "X1": FieldData(
            ty: CellRef,
            default: None,
            aliases: [
                "A1",
            ],
        ),
        "X2": FieldData(
            ty: CellRef,
            default: None,
            aliases: [
                "A2",
            ],
        ),
        "X3": FieldData(
            ty: CellRef,
            default: None,
            aliases: [
                "A3",
            ],
        ),
        "X4": FieldData(
            ty: CellRef,
            default: None,
            aliases: [
                "A4",
            ],
        ),
        "heap_ptr": FieldData(
            ty: CellRef,
            default: None,
            aliases: [
                "H",
                "hp",
            ],
        ),
        "instr_ptr": FieldData(
            ty: Usize,
            default: Some(Usize(0)),
            aliases: [
                "P",
                "ip",
            ],
        ),
        "mode": FieldData(
            ty: Symbol,
            default: Some(Symbol("read")),
            aliases: [],
        ),
        "structure_ptr": FieldData(
            ty: CellRef,
            default: None,
            aliases: [
                "S",
            ],
        ),
    },
    instr_scripts: {
        "get_structure": Script(
            sections: [
                Doc("The `get_structure` instruction starts by dereferencing A1\nand checking whether it is free\n- If it is free, it sets the current mode to `Mode::Write`. This makes\nthe rest of the `get_structure` behave like `put_structure`, and it\nmakes the subsequent `unify_variable` instructions behave like\n`set_variable`.\n- If it is bound, it sets the current mode to `Mode::Read`. This makes\nthe rest of the `get_structure` and the subsequent `unify_variable`\ninstructions do matching against the existing term, instead of\nconstructing a new one.\n\n# Alternate Explanation\nThis instruction marks the beginning of a structure (without embedded\nsubstructures) occurring as a head argument. The instruction gets the\nvalue of register Ai and dereferences it. If the result is a\nreference to a variable, that variable is bound to a new structure\npointer pointing at the top of the heap, and the binding is trailed\nif necessary, functor F is pushed onto the heap, and execution\nproceeds in \"write\" mode. Otherwise, if the result is a structure and\nits functor is identical to functor F, the pointer S is set to point\nto the arguments of the structure, and execution proceeds in \"read\"\nmode. Otherwise, backtracking occurs.\n\nScript for instruction `get_structure`\nFeel free to edit this file however you like.\nRemember to use `$1`, `$2`, etc to refer to the instruction\'s parameters.\n\n"),
                Cmd("$1.*\n.reply <- ask bound or unbound?\nif .reply == :bound\n    mode <- :read\n    .heap_f <- $1.*[0]\n    if .heap_f == $2\n        S <- $1.*[1].&\n    end\nelse\n    :todo\nend\nnext\n"),
                Doc(""),
            ],
        ),
        "unify_variable": Script(
            sections: [
                Doc("# unify_variable Vn\nThis instruction represents a head structure argument that is an\nunbound variable. If the instruction is executed in \"read\" mode, it\nsimply gets the next argument from S and stores it in variable Vn. If\nthe instruction is executed in \"write\" mode, it pushes a new unbound\nvariable onto the heap, and stores a reference to it in variable Vn.\n\nIn read mode:\n\nVn := next_term(S)\n\nIn write mode:\n\nVn := next_term(H) = tag_ref(H)\n\nScript for instruction `unify_variable`\nFeel free to edit this file however you like.\nRemember to use `$1`, `$2`, etc to refer to the instruction\'s parameters.\n\n"),
                Cmd("if mode == :read\n    $1.* <- S.*\n    S <- S[1].&\nelse\n    push tm _\n    $1 <- H\nend\n"),
                Doc(""),
            ],
        ),
    },
    preferred_editor: Some("notepad.exe"),
)